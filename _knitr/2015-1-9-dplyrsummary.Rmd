---
layout: post
title: dplyr, enhancing my R experience
description: I turned a behemoth function into a simple chunk to summarize my data
tags: [R]
comments: true
---

When I get data, one of the first things that I want to do is get a basic summary and make some plots to look at things. I usually start with getting the mean, SD, and SE. A few years ago, this required using aggregate and some sort of apply function. Then, I discovered plyr and wrote a function of my own. It allowed you to get these data out and then generate graphs for them. I generated some random data, that looks like this: 

````{r data, echo = FALSE}
var1 <- c(rep("a",9), rep("b", 9), rep("c", 9))
var2 <- rep(c(rep("high", 3), rep("med", 3), rep("low", 3)),3)
out1 <- rnorm(27, mean = 50)
out2 <- rnorm(27, mean = 100)
out3 <- rnorm(27, mean = 5)
data <- as.data.frame(cbind(var1, var2, out1, out2, out3))

if(!require(plyr)) { 
install.packages("plyr"); require(plyr)} 
colwise(class)(data)

# right now, everything is a factor, convert out1, out2, and out 3 to numeric values
data$out1<-as.numeric(data$out1)
data$out2<-as.numeric(data$out2)
data$out3<-as.numeric(data$out3)

head(data)
````


I then had this clunky and old function that ran over all of the data and gave you an output of means, SD, and SE:

````{r function}
if(!require(plyr)) { 
install.packages("plyr"); require(plyr)} 

summarydata <- function (df,splittingfactors=NULL, convert_integers=F, calc_mean=T, calc_sd=T, calc_se=T){
  
  if((convert_integers)){
    for (i in 1:length(df)) if (is.integer(df[,i]))(df[,i]<-as.factor(df[,i]))
  }
  
  #this section gets an index of factors and numeric variables to use later
  v.numeric <- (rep(0,length(df)))
  v.factor <- (rep(0,length(df)))
  for (i in 1:length(df)) if (is.factor(df[,i])) (v.factor[i]<-as.vector((names(df[i]))))
  for (i in 1:length(df)) if (is.numeric(df[,i])) (v.numeric[i]<-as.vector((names(df[i]))))
  v.factor<-v.factor[!v.factor==0]
  v.numeric<-v.numeric[!v.numeric==0]
  
  if(!is.null(splittingfactors)){
    v.factor <- as.vector(c(splittingfactors))
  }
  
  # each of these three if loops calculate mean, sd, and se for each column (numcolwise) and then combines into a results df
  if(calc_mean){
    mean.res <- ddply(df, c(v.factor), numcolwise(mean, na.rm=TRUE))
    mean.names <- (rep(0,length(v.numeric)))
    for (i in 1:length(v.numeric)) (mean.names[i]<-as.vector(paste(v.numeric[i],"mean",sep=".")))
    column.names <- c(v.factor,mean.names)
    colnames(mean.res) <- column.names
  }
  
  if(calc_sd){
    sd.res <- ddply(df, c(v.factor), numcolwise(sd, na.rm=TRUE))
    sd.names <- (rep(0,length(v.numeric)))
    for (i in 1:length(v.numeric)) (sd.names[i]<-as.vector(paste(v.numeric[i],"sd",sep=".")))
    column.names <- c(v.factor,sd.names)
    colnames(sd.res) <- column.names
    ifelse(calc_mean,ifelse(calc_sd,mean.sd.res <- merge(mean.res,sd.res), mean.sd.res<-mean.res),mean.sd.res<-sd.res)
  }

  
  if(calc_se){
    se <- function(x) sqrt(var(x,na.rm=TRUE)/length(na.omit(x)))
    se.res <- ddply(df, c(v.factor), numcolwise(se))
    se.names <- (rep(0,length(v.numeric)))
    for (i in 1:length(v.numeric)) (se.names[i]<-as.vector(paste(v.numeric[i],"se",sep=".")))
    column.names <- c(v.factor,se.names)
    colnames(se.res) <- column.names
  }
  ifelse(calc_mean, ifelse(calc_sd, ifelse(calc_se, results <- merge(mean.sd.res,se.res), results <- merge(mean.res, se.res)), ifelse(calc_se, results<- merge(mean.res,se.res), results <- mean.res)), ifelse(calc_sd, ifelse(calc_se, results <- merge(sd.res,se.res), results <- sd.res), results <- se.res))
              
  
  return(results)
}
````

We can then run the code on our dataframe of choice and see the output
````{r test}
sumd <- summarydata(data)
sumd
````

## dplyr

That works fine, actually, but with bigger data frames, the speed isn't that good. I wanted to streamline the code. I'm using the [dplyr](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html) package instead of the plyr package, which has slightly different syntax, but still has some constraints. Here's what I've come up with(assuming you've checked the class of each variable that you want to work with):

````{r summary2, message=FALSE}
if(!require(dplyr)) { 
  install.packages("dplyr"); require(dplyr)} 

se <- function(x) sqrt(var(x,na.rm=TRUE)/length(na.omit(x)))

summaryresults <-
  data %>% 
  group_by(var1, var2) %>%
  summarise_each(funs(mean, sd, se))
summaryresults
````

With four lines, I can now do the same with what I did before. Though I was quite fond of my old funciton (we had a good run together), this new method makes things much easier and faster.